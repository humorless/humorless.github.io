<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://humorless.github.io/' rel='self' type='application/rss+xml'/>
<title>
Full Stack Clojure (全棧閉包)
</title>
<link>
https://humorless.github.io/
</link>
<description>
This personal blog describes about the ideas around Clojure/ClojureScript/Datomic
</description>
<lastBuildDate>
Sat, 27 Apr 2019 04:53:06 +0000
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://humorless.github.io/posts-output/datomic
</guid>
<link>
https://humorless.github.io/posts-output/datomic
</link>
<title>
Using Datomic in my app
</title>
<description>
&lt;h2 id=&quot;the&amp;#95;background&amp;#95;of&amp;#95;this&amp;#95;post&quot;&gt;The background of this post&lt;/h2&gt;&lt;p&gt;I began to use Datomic seriesly in my project at work from February 2019. Now, it is time to write down certain experience. When I just began, I found quite a lot of documents talking about how to use Datomic. However, I still found certain points worth to mention from my own project.&lt;/p&gt;&lt;h2 id=&quot;query&amp;#95;api&amp;#95;and&amp;#95;pull&amp;#95;api&amp;#95;are&amp;#95;enough&quot;&gt;Query API and Pull API are enough&lt;/h2&gt;&lt;p&gt;When I just begin to write Datomic, soon I found &lt;a href='https://vvvvalvalval.github.io/posts/2016-07-24-datomic-web-app-a-practical-guide.html'&gt;post&lt;/a&gt; from Val. In the post, Val used Entity API. &lt;/p&gt;&lt;p&gt;In my project, I used only Query API and Pull API. Query API was for taking out entity id mostly and Pull API was for pulling out necessary field or sometimes doing some 'join'. I think the article &lt;a href='http://blog.cognitect.com/blog/2017/4/21/separation-of-concerns-in-datomic-query-datalog-query-and-pull-expressions'&gt;SEPARATION OF CONCERNS IN DATOMIC QUERY: DATALOG QUERY AND PULL EXPRESSIONS&lt;/a&gt; has explained similar idea. Entity API is also good, but Pull API is even better.&lt;/p&gt;&lt;h2 id=&quot;occasionally,&amp;#95;a&amp;#95;generalized&amp;#95;cas&amp;#95;(compare-and-swap)&amp;#95;is&amp;#95;needed,&amp;#95;or&amp;#95;you&amp;#95;need&amp;#95;to&amp;#95;use&amp;#95;stamp.&quot;&gt;Occasionally, a generalized CAS (compare-and-swap) is needed, or you need to use stamp.&lt;/h2&gt;&lt;p&gt;In my project, I need to use Datomic to model:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The user can propose request. Initially, the request is in open status.&lt;/li&gt;&lt;li&gt;The admin can approve/reject/modify the user request.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The request schema is like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:req/status     ;; cardinality one. It can be - open, modified, approved, rejected
:req/things     ;; cardinality many. &amp;#91;thing-id ...&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The admin sees the user requests from a web application UI. There are three options for admin: approve, reject, modify. If a request is approved or rejected, then this request is no longer alive. It will disappear from admin UI. However, if a request is modified, it can still be approved, be rejected, or be modified again. When the request is modified, only the &lt;code&gt;req/things&lt;/code&gt; can be modified. There may be multiple admins operating at the same time on the same request in this system.&lt;/p&gt;&lt;p&gt;The state diagram of request status is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; open -&amp;gt; modified 
 modified -&amp;gt; modified 
 {modified, open} -&amp;gt; approved &amp;#40;done&amp;#41;
 {modified, open} -&amp;gt; rejected &amp;#40;done&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Consider a situation: Two admins A and B process on the same request and they do not sense each other. They push the button at the same time. One admin A approves the request and another admin B modifies the request. The request was originally modified before, so it is at the status &lt;code&gt;modified&lt;/code&gt; when the two admins process it.&lt;/p&gt;&lt;p&gt;The correct behavior of the system could be two possibilities: Either operation of admin A is successful or operation of admin B is successful. If operation of admin A is successful first, then the request can not be modified anymore. If the operation of admin B is successful first, then the approval of A should not happen, because the &lt;code&gt;req/things&lt;/code&gt; is already modified, but the admin A approved different set of &lt;code&gt;req/things&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I consider to utilize &lt;code&gt;db.fn/cas&lt;/code&gt; to guarantee that only one operation of admin A or admin B can succeed. However, &lt;code&gt;db.fn/cas&lt;/code&gt; does not work on attributes with cardinality many.&lt;/p&gt;&lt;p&gt;I think there are two ways to solve this mutually-exclusive concurrent operation problem:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Add an additional schema &lt;code&gt;req/stamp&lt;/code&gt; into req. The stamp is initially 0. Every operation will increase it by 1. Then I can use this stamp and &lt;code&gt;db.fn/cas&lt;/code&gt; to ensure the logically strictness of the operations.&lt;/li&gt;&lt;li&gt;Install some customized db function, which can do CAS on cardinality many to ensure the logically strictness.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;db&amp;#95;enumeration&quot;&gt;DB Enumeration&lt;/h2&gt;&lt;p&gt;I use &lt;code&gt;:db/ident&lt;/code&gt; to do enumerations in my project:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;:db/add #db/id &amp;#91;:db.part/user&amp;#93; :db/ident :product.type/account&amp;#93;
&amp;#91;:db/add #db/id &amp;#91;:db.part/user&amp;#93; :db/ident :product.type/display&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;They are enumerations that represent the different products. Then, there are certain related issues associated with this modeling.&lt;/p&gt;&lt;h3 id=&quot;how&amp;#95;to&amp;#95;pull&amp;#95;out&amp;#95;all&amp;#95;the&amp;#95;enumerations&amp;#95;of&amp;#95;the&amp;#95;same&amp;#95;type?&quot;&gt;How to pull out all the enumerations of the same type?&lt;/h3&gt;&lt;p&gt;I deliberately set the enumeration of the same type with the same namespace, so I need to prepare a query that can filter based on the same namespace. It is very convenient that we can directly use Clojure function in datomic query.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn product-enum-eids
  &amp;quot;all the product enumeration eids&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;d/q '&amp;#91;:find &amp;#91;?e ...&amp;#93;
         :in $ ?nsp
         :where &amp;#91;?e :db/ident ?attr&amp;#93;
         &amp;#91;&amp;#40;namespace ?attr&amp;#41; ?nsp&amp;#93;&amp;#93;     ;;Datomic Function expression binds the ?nsp variable
       db &amp;quot;product.type&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;how&amp;#95;to&amp;#95;store&amp;#95;the&amp;#95;external&amp;#95;string&amp;#95;and&amp;#95;enumeration&amp;#95;mapping&amp;#95;in&amp;#95;datomic?&quot;&gt;How to store the external string and enumeration mapping in Datomic?&lt;/h3&gt;&lt;p&gt;Once again, I use simple schema with no magic.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   {:db/doc &amp;quot;External name associated with a db enumeration value&amp;quot;
    :db/ident :enum/name
    :db/valueType :db.type/string
    :db/cardinality :db.cardinality/one
    :db/unique :db.unique/identity
    :db/id #db/id &amp;#91;:db.part/db&amp;#93;
    :db.install/&amp;#95;attribute :db.part/db}

   {:db/doc &amp;quot;db enumeration value&amp;quot;
    :db/ident :enum/value
    :db/valueType :db.type/ref
    :db/cardinality :db.cardinality/one
    :db/unique :db.unique/identity
    :db/id #db/id &amp;#91;:db.part/db&amp;#93;
    :db.install/&amp;#95;attribute :db.part/db}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we need to import data from files and we need to map external names to DB enumeration values, we can pull out all the mapping at once. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn name2enum-table
  &amp;quot;create a mapping table that can lookup enumeration from string name.&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;into {}  &amp;#40;d/q '&amp;#91;:find ?k ?enum
                   :where
                   &amp;#91;?e :enum/name ?k&amp;#93;
                   &amp;#91;?e :enum/value ?v&amp;#93;
                   &amp;#91;?v :db/ident ?enum&amp;#93;&amp;#93;
                 db&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Sat, 27 Apr 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/REPL
</guid>
<link>
https://humorless.github.io/posts-output/REPL
</link>
<title>
REPL tips
</title>
<description>
&lt;p&gt;從今年 2 月開始，接了一個公司內部應用軟體的專案開發，我用 clojure + luminus + datomic 來實作。不知不覺也就每天寫 clojure 的 REPL 近兩個月了。每天玩 REPL 之後，很快就發現一些過去我用 REPL 的盲點。&lt;/p&gt;&lt;h3 id=&quot;沒有善用&amp;#95;&lt;code&gt;clojure.repl/pprint&lt;/code&gt;&quot;&gt;沒有善用 &lt;code&gt;clojure.repl/pprint&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;  沒有善用的主要原因，自然是因為在 &lt;code&gt;fireplace.vim&lt;/code&gt; 的環境下，一開始我沒有特別做一些設定時，直接做 cpp, cqp 之類 REPL 操作，並不會有 pretty print 的輸出。後來，我總算是下定決心，把 &lt;a href='https://github.com/humorless/dotfiles/blob/master/profiles.clj'&gt;leiningen profiles&lt;/a&gt; 設定好，加入了一個叫 &lt;code&gt;vinyasa&lt;/code&gt; 的 leiningen dependency&lt;/p&gt;&lt;p&gt;  設定好之後，就可以用 &lt;code&gt;&amp;#40;&amp;gt;pprint ...&amp;#41;&lt;/code&gt; 來做 pretty print 。&lt;/p&gt;&lt;h3 id=&quot;沒有善用&amp;#95;&lt;code&gt;&amp;#42;1&lt;/code&gt;&amp;#95;&lt;code&gt;&amp;#42;2&lt;/code&gt;&quot;&gt;沒有善用 &lt;code&gt;&amp;#42;1&lt;/code&gt; &lt;code&gt;&amp;#42;2&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;  過去，我在做 REPL 操作時，常常做的事情是這樣子：&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f1 a b c&amp;#41;&lt;/code&gt; =&gt; 試到結果正確&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f2 &amp;#40;f1 a b c&amp;#41; d&amp;#41;&lt;/code&gt; =&gt; 也是試到結果也正確&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f3 &amp;#40;f2 &amp;#40;f1 a b c&amp;#41; d&amp;#41; e&amp;#41;&lt;/code&gt; =&gt; 然後指令就愈來愈長, 愈來愈難下&lt;/p&gt;&lt;p&gt;  其實不用這樣子麻煩，第二次可以這樣子下指令 &lt;code&gt;&amp;#40;f2 &amp;#42;1 d&amp;#41;&lt;/code&gt; 。&lt;/p&gt;
</description>
<pubDate>
Sat, 30 Mar 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/dependency-injection
</guid>
<link>
https://humorless.github.io/posts-output/dependency-injection
</link>
<title>
dependency injection with Clojure
</title>
<description>
&lt;p&gt;寫 clojure 的時候，雖然套用了 REPL-driven development 的開發方式，已經相對可以讓大多數的函數很快地做過測試。但是，隨著要開發的專案愈來愈大，還是一樣需要用標準的寫法來寫單元測試 (unit test) 。有一個非正規的統計，如果是 Ruby on Rail 的專案，一般而言，90% 的函數都是有副作用的。然而， clojure 語言的專案，往往只有 40% 的函數帶有副作用。&lt;/p&gt;&lt;p&gt;即使是寫 clojure 語言，還是會遇到有 side effect 的函數，那比較好的寫法是怎麼樣呢？&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;p&gt;我查了一下 stackoverflow 之後，很快就找到了一個很好用的函數 &lt;code&gt;with-redefs&lt;/code&gt; 。 stackoverflow 上的答案大意如下： 由於 clojure 語言有 Dynamic binding 的特性，使用 &lt;code&gt;with-redefs&lt;/code&gt; 就可以實現同樣的語意了。&lt;/p&gt;&lt;p&gt;我試了一下，還真的管用，範例如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;deftest platform-contact-test
  &amp;#40;testing &amp;quot;platform-contact&amp;quot;
    ; use the DI technique to test the function platform-contact
    &amp;#40;is &amp;#40;= 170
           &amp;#40;with-redefs &amp;#91;get-platform-contact &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;slurp &amp;quot;./resources/contact&amp;#95;data.txt&amp;quot;&amp;#41;&amp;#41;&amp;#93;
             &amp;#40;count &amp;#40;platform-contact &amp;#40;temp-platform-all&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在這個範例中，原本的 &lt;code&gt;get-platform-contact&lt;/code&gt; 函數是一個有副作用的函數，它會被 &lt;code&gt;platform-contact&lt;/code&gt; 函數呼叫。 &lt;code&gt;get-platform-contact&lt;/code&gt; 函數會發出一個 http request ，並且傳回遠端 server 上的資料，所以如果沒有加以代換，單元測試就會非常慢。用了 &lt;code&gt;with-redefs&lt;/code&gt; 之後，就可以輕易地將 &lt;code&gt;get-platform-contact&lt;/code&gt; 代換成一個會傳回固定檔案資料的函數，如此就可以執行快速的單元測試了。&lt;/p&gt;&lt;p&gt;對於 clojure 這種先進的特性， stackoverflow 上有一句評論： Needing a framework for DI is really just compensating for a lack of sufficient features in the language itself.&lt;/p&gt;
</description>
<pubDate>
Wed, 12 Jul 2017 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/groupby
</guid>
<link>
https://humorless.github.io/posts-output/groupby
</link>
<title>
groupby
</title>
<description>
&lt;p&gt;一開始是我在寫 &lt;a href='http://www.4clojure.com/problem/63'&gt;4clojure&lt;/a&gt; 的練習題的時候，寫到了一個題目，要重新實現 clojure 語言的 groupby 函數。我糾結了好一陣子，又查了不少資料，才勉強用 reduce 寫出來。然而，最近卻在工作中，用上了 groupby 。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn f &amp;#91;k coll&amp;#93;
  &amp;#40;reduce
    &amp;#40;fn &amp;#91;c v&amp;#93;
      &amp;#40;update-in c &amp;#91;&amp;#40;k v&amp;#41;&amp;#93; &amp;#40;fnil conj &amp;#91;&amp;#93;&amp;#41; v&amp;#41;&amp;#41;
    {} coll&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt; 工作上遇到的問題是要重構同事寫的程式碼。程式碼做的事情是：「接受資料庫 dump 的 json 輸出，跑兩層很複雜的迴圈，對原始的資料做主鍵交換的處理，然後將資料存入 mysql 資料庫。」資料庫 dump 出來的 json 大概長成如下的樣子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;  &amp;quot;result&amp;quot;: &amp;#91;
    {
      &amp;quot;platform&amp;quot;: &amp;quot;c01.i01&amp;quot;,
      &amp;quot;ip&amp;#95;list&amp;quot;: &amp;#91;
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.168.0.1&amp;quot;,
          &amp;quot;hostname&amp;quot;: &amp;quot;ggyy6699&amp;quot;
        },
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.169.1.1&amp;quot;,
          &amp;quot;hostname:&amp;quot;: &amp;quot;ggyy7700&amp;quot;
        }
      &amp;#93;
    },
    {
      &amp;quot;platform&amp;quot;: &amp;quot;c01.i05&amp;quot;,
      &amp;quot;ip&amp;#95;list&amp;quot;: &amp;#91;
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.168.0.2&amp;quot;,
          &amp;quot;hostname&amp;quot;: &amp;quot;ggkk8899&amp;quot;
        },
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.169.1.2&amp;quot;,
          &amp;quot;hostname:&amp;quot;: &amp;quot;ggkk9900&amp;quot;
        }
      &amp;#93;
    }
  &amp;#93;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;從這個 json 來看的話，&lt;code&gt;platform&lt;/code&gt; 是主鍵 (primary key) 。而每一個 &lt;code&gt;platform&lt;/code&gt; 下之下會有多個 &lt;code&gt;hostname&lt;/code&gt; 。而程式碼做的事情是，先解析這個 json ，重新整理之後，讓 &lt;code&gt;hostname&lt;/code&gt; 變成主鍵 (primary key) ，並且做成一行又一行的 row ，最後要存入關聯式資料庫。讓我感到困擾的地方是因為整理屬性與屬性之間複雜關系的程式碼，都塞在雙重迴圈裡頭，所以雙重迴圈就變得很複雜，而且這一段雙重迴圈的程式碼也無法複用，難以修改、難以維護。&lt;/p&gt;&lt;p&gt;轉換成用資料庫的觀點來看待這個問題之後，就得到了還不錯的解法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;資料庫的 dump 輸出，本質上也是 join 兩張資料表的結果輸出，所以主鍵 (primary key) 本來就有可能交換。&lt;/li&gt;&lt;li&gt;既然要解析的資料是 join 之後的結果，所以有效的處理方式是這樣子：&lt;ol&gt;&lt;li&gt;先將 json 的資料跑完簡單的雙重迴圈，雙重迴圈只做一件事，只將將資料做展開 (unfolding)，變成 join 完成的樣子。&lt;/li&gt;&lt;li&gt;python 的 &lt;code&gt;itertools.groupby&lt;/code&gt; ，可以讓資料表 (table) 重新整理，產生出以任意的 column 做為主鍵 (primary key) 的新資料表 (table)。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程式碼如下：&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def get&amp;#95;h&amp;#95;platforms&amp;#40;res&amp;#41;:
    &amp;quot;&amp;quot;&amp;quot; sample output
    ctl-zj-061-130-028-019 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    ctl-zj-061-130-028-020 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    ctl-zj-061-130-028-022 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    &amp;quot;&amp;quot;&amp;quot;
    product = &amp;#91;&amp;#40;p&amp;#91;&amp;quot;platform&amp;quot;&amp;#93;, device&amp;#91;&amp;quot;hostname&amp;quot;&amp;#93;&amp;#41;
               for p in res&amp;#91;&amp;quot;result&amp;quot;&amp;#93; for device in p&amp;#91;&amp;quot;ip&amp;#95;list&amp;quot;&amp;#93;&amp;#93;
    data = sorted&amp;#40;product, key=lambda x: x&amp;#91;1&amp;#93;&amp;#41;
    for key, grp in itertools.groupby&amp;#40;data, key=lambda x: x&amp;#91;1&amp;#93;&amp;#41;:
        print&amp;#40;key, list&amp;#40;map&amp;#40;lambda x: x&amp;#91;0&amp;#93;, set&amp;#40;grp&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sun, 21 May 2017 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/pattern
</guid>
<link>
https://humorless.github.io/posts-output/pattern
</link>
<title>
pattern
</title>
<description>
&lt;h2 id=&quot;patterns&amp;#95;=&amp;#95;programming&amp;#95;with&amp;#95;abstactions&amp;#95;that&amp;#95;are&amp;#95;not&amp;#95;powerful&amp;#95;enough&quot;&gt;patterns = programming with abstactions that are not powerful enough&lt;/h2&gt;&lt;p&gt;先來引述一下 Paul Graham 的句子&lt;blockquote&gt;&lt;p&gt; When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I'm using abstractions that aren't powerful enough. &lt;/p&gt;&lt;footer&gt; Paul Graham - Revenge of the Nerds&lt;/footer&gt; &lt;/blockquote&gt;為了想出可以妥善解釋這段話的意思的 non-trivial 範例，其實我還想了滿久的。不料真的就在我學習 clojure 語言的過程之中找到了。這個範例是對某個 array 的每一個元素，做相同的運算處理：一個是循序處理、一個是平行處理。&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;h3 id=&quot;golang&amp;#95;的兩個版本&quot;&gt;golang 的兩個版本&lt;/h3&gt;&lt;p&gt;循序處理的版本&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;res := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
for i,xi := range data {
    func &amp;#40;i int, xi float&amp;#41; {
        res&amp;#91;i&amp;#93; = doSomething&amp;#40;i,xi&amp;#41;;
    } &amp;#40;i, xi&amp;#41;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;平行處理的版本&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;type empty {}
...
data := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
res := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
sem := make&amp;#40;chan empty, N&amp;#41;;  // semaphore pattern
...
for i,xi := range data {
    go func &amp;#40;i int, xi float&amp;#41; {
        res&amp;#91;i&amp;#93; = doSomething&amp;#40;i,xi&amp;#41;;
        sem &amp;lt;- empty{};
    } &amp;#40;i, xi&amp;#41;;
}
// wait for goroutines to finish
for i := 0; i &amp;lt; N; ++i { &amp;lt;-sem }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;h3 id=&quot;clojure&amp;#95;的兩個版本&quot;&gt;clojure 的兩個版本&lt;/h3&gt;&lt;p&gt;循序處理的版本&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn myfun &amp;#91;coll&amp;#93;
  &amp;#40;map doSomething coll&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;平行處理的版本&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn myfun &amp;#91;coll&amp;#93;
  &amp;#40;pmap doSomething coll&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;抽象層次的差異&quot;&gt;抽象層次的差異&lt;/h3&gt;&lt;p&gt;比較這兩種語言寫的四段程式碼，很快可以發現，循序處理的範例都相當的簡單。然而，當換成平行處理的版本時， golang 的實作比 clojure 難多了。需要用 golang 的 channel 做出一個 semaphore 的 pattern 才能實現。而相較之下， clojure 把 map 換成 pmap 就可以了。由此可見， clojure 在這個例子之中，是一種足夠強的抽象層，可以輕易地去表達這個平行處理的語意。&lt;/p&gt;
</description>
<pubDate>
Tue, 28 Feb 2017 00:00:00 +0000
</pubDate>
</item>
</channel>
</rss>
