<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://humorless.github.io/' rel='self' type='application/rss+xml'/>
<title>
Let over map merge
</title>
<link>
https://humorless.github.io/
</link>
<description>
This personal blog describes about the ideas around Clojure/ClojureScript/Datomic
</description>
<lastBuildDate>
Fri, 09 Aug 2019 16:17:58 +0000
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://humorless.github.io/posts-output/etl
</guid>
<link>
https://humorless.github.io/posts-output/etl
</link>
<title>
A Clojurian's idioms and patterns for ETL
</title>
<description>
&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;&lt;p&gt;I needed to do eight Excel ETLs at my project. At the beginning, I just implemented some of the ETLs without any design. I did not even implement schema validation, and then I felt the pain soon. After several re-writing, I abstracted out some idioms and patterns for ETL.&lt;/p&gt;&lt;h2 id=&quot;problems&quot;&gt;Problems&lt;/h2&gt;&lt;p&gt;We need to import data from several Excel files into Datomic database. There are several concerns with the ETL (extract-transform-load):&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Schema validation:   Can we have a validation function that we only need to inject the schema and then the validation function will handle all the rest for us? &lt;/li&gt;&lt;li&gt;Transformation complexity:   The transformation from Excel to Datomic table varies a lot. The simplest one is just copy data, but the complex ones need to look up tables in the database. How can we organize different type of transformation functions such that the functions can be more reusable and composable?&lt;/li&gt;&lt;li&gt;Database upsert semantic:   The identity key of the database table may be compound fields, or there may be some cardinality-many fields in the database table. That is to say, the basic upsert semantic offered by Datomic is not enough.&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;solution&amp;#95;for&amp;#95;schema&amp;#95;validation&quot;&gt;Solution for schema validation&lt;/h3&gt;&lt;p&gt;The library &lt;code&gt;clojure.spec&lt;/code&gt; is great for schema validation. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;;; library functions defined at utility namespace
&amp;#40;defn check-raw-fn
  &amp;quot;assemble schema and then create a validation fn&amp;quot;
  &amp;#91;schema&amp;#93;
  &amp;#40;fn check-raw
    &amp;#91;data&amp;#93;
    &amp;#40;if &amp;#40;spec/valid? schema data&amp;#41;
      data
      &amp;#40;let &amp;#91;desc &amp;#40;spec/explain-str schema data&amp;#41;&amp;#93;
        &amp;#40;throw &amp;#40;ex-info desc {:causes data :desc desc}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;; Example application functions
&amp;#40;spec/def ::apply-time inst?&amp;#41;
&amp;#40;spec/def ::customer-id string?&amp;#41;
&amp;#40;spec/def ::lamp-customer-id string?&amp;#41;
&amp;#40;spec/def ::sales-name string?&amp;#41;
&amp;#40;spec/def ::source #{&amp;quot;agp&amp;quot; &amp;quot;lap&amp;quot;}&amp;#41;

&amp;#40;spec/def ::mapping
  &amp;#40;spec/&amp;#42; 
    &amp;#40;spec/keys :req-un
               &amp;#91;::apply-time ::customer-id ::lamp-customer-id ::sales-name ::source&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def &amp;#94;:private check-raw
  &amp;#40;utility/check-raw-fn ::mapping&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this design:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Even though I do not know how many rows an Excel file may have, I can still use &lt;code&gt;&amp;#40;spec/&amp;#42; ...&amp;#41;&lt;/code&gt; to represent the schema for the Excel file. If the spec does not offer the semantic like &lt;code&gt;&amp;#40;spec/&amp;#42; ...&amp;#41;&lt;/code&gt;, I have to write some loop logic in &lt;code&gt;check-raw-fn&lt;/code&gt; function, which causes the context dependency.&lt;/li&gt;&lt;li&gt;The spec names are just the same as the column names of Excel. Keep it simple making the program more robust.&lt;/li&gt;&lt;li&gt;If a string has only a few possible options, represent it in the form as &lt;code&gt;#{option1 option2 ...}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;When throwing exception, I use &lt;code&gt;&amp;#40;ex-info ...&amp;#41;&lt;/code&gt; and I put the output of &lt;code&gt;&amp;#40;spec/explain-str ...&amp;#41;&lt;/code&gt; into an exception. Then, I can find out what is wrong by just reading the exception message. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Also, at the trigger API of ETL, the web API deliberately catches only certain types of Exception:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;try &amp;#40;if-let &amp;#91;r &amp;#40;etl/sync-data cmd filename&amp;#41;&amp;#93;
            &amp;#40;ok {:result :insert-done}&amp;#41;
            &amp;#40;ok {:result :already-sync}&amp;#41;&amp;#41;
          &amp;#40;catch clojure.lang.ExceptionInfo e
            &amp;#40;bad-request {:reason &amp;#40;ex-data e&amp;#41;}&amp;#41;&amp;#41;
          &amp;#40;catch java.util.concurrent.ExecutionException e
            &amp;#40;bad-request {:reason &amp;#40;.getCause e&amp;#41;}&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The exception &lt;code&gt;clojure.lang.ExceptionInfo&lt;/code&gt; only catches the schema validation error thrown by my application code. The exception &lt;code&gt;java.util.concurrent.ExecutionException&lt;/code&gt; can catch the error from Datomic transaction. Other exceptions may happen with lower possibility, so I let them pass over and be recorded in log file.&lt;/p&gt;&lt;h3 id=&quot;solution&amp;#95;for&amp;#95;transformation&amp;#95;complexity&amp;#95;&amp;mdash;&amp;#95;let&amp;#95;over&amp;#95;map&amp;#95;merge&quot;&gt;Solution for transformation complexity &amp;mdash; let over map merge&lt;/h3&gt;&lt;p&gt;I propose a pattern, which I call it as &lt;code&gt;let over map merge&lt;/code&gt; to handle the transformation complexity.&lt;/p&gt;&lt;p&gt;Consider a transformation function &lt;code&gt;data-&amp;gt;txes&lt;/code&gt;, both the input and the output are sequences of map:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The single map in the input data represents the row in the Excel file.&lt;/li&gt;&lt;li&gt;The single map in the output &lt;code&gt;txes&lt;/code&gt; represents the row in the Datomic table.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- data-&amp;gt;txes
  &amp;quot;data is a sequence of {HashMap}&amp;quot;
  &amp;#91;data&amp;#93;
  &amp;#40;let &amp;#91;db &amp;#40;d/db conn&amp;#41;
        table &amp;#40;utility/tax-id-&amp;gt;c-eid db&amp;#41;&amp;#93;
    &amp;#40;map #&amp;#40;transformation-f table %&amp;#41; data&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can easily divide the transformation into two categories:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Basic transformation: Just copy the field, or with pure function transformation.&lt;/li&gt;&lt;li&gt;Complex transformation: When transforming the input data, we need to also look up the database content.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If we pull out &lt;code&gt;basic-mapping&lt;/code&gt; and &lt;code&gt;complex-mapping&lt;/code&gt; from &lt;code&gt;transformation-f&lt;/code&gt;, we can change the original code into&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn- data-&amp;gt;txes
  &amp;#91;data&amp;#93;
  &amp;#40;let &amp;#91;db &amp;#40;d/db conn&amp;#41;
        table &amp;#40;utility/tax-id-&amp;gt;c-eid db&amp;#41;&amp;#93;
    &amp;#40;let &amp;#91;basic-tx &amp;#40;map basic-mapping data&amp;#41;
          complex-tx &amp;#40;map #&amp;#40;complex-mapping table %&amp;#41; data&amp;#41;&amp;#93;
      &amp;#40;map merge basic-tx complex-tx&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this &lt;code&gt;let over map-merge&lt;/code&gt; pattern, we can make the granularity of the transformation function smaller so as to make them more reusable and composable. In certain cases, basic-mapping only needs to change the key-name in the hash map, so we can use &lt;code&gt;clojure.set/rename-keys&lt;/code&gt; to implement the basic-mapping.&lt;/p&gt;&lt;h3 id=&quot;solution&amp;#95;for&amp;#95;database&amp;#95;upsert&amp;#95;semantic&quot;&gt;Solution for database upsert semantic&lt;/h3&gt;&lt;p&gt;In Datomic, we can use the &lt;code&gt;:db.unique/identity&lt;/code&gt; to make certain schema work like primary key in traditional RDBMS. &lt;/p&gt;&lt;h4 id=&quot;compound&amp;#95;primary&amp;#95;key&quot;&gt;Compound primary key&lt;/h4&gt;&lt;p&gt;Consider tha table with compound primary key as &lt;code&gt;stream-unique-id, writing-time, source&lt;/code&gt;. How to do upsert when we have &lt;code&gt;txes&lt;/code&gt; like below?&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;#91;#:rev-stream{:stream-unique-id &amp;quot;AA&amp;quot;
               :writing-time #inst &amp;quot;2019-04-01T02:39:00.000-00:00&amp;quot;
               :source :etl.source/agp
               :campaign-name &amp;quot;BB&amp;quot;}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With a db transaction function &lt;code&gt;upsert-rev-stream&lt;/code&gt;, we can simply write &lt;code&gt;txes&lt;/code&gt; as &lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;#91;&amp;#91;:fn/upsert-rev-stream 
   #:rev-stream{:stream-unique-id &amp;quot;AA
                :writing-time #inst &amp;quot;2019-04-01T02:39:00.000-00:00&amp;quot;
                :source :etl.source/agp
                :campaign-name &amp;quot;BB&amp;quot;}&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The transaction function &lt;code&gt;:fn/upsert-rev-stream&lt;/code&gt; handles the upsert complexity.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; {:db/id #db/id &amp;#91;:db.part/user&amp;#93;
  :db/ident :fn/upsert-rev-stream
  :db/doc &amp;quot;The primary key of rev-stream is compound key&amp;quot;
  :db/fn #db/fn
  {:lang :clojure
   :params &amp;#91;db m&amp;#93;
   :code &amp;#40;if-let &amp;#91;id &amp;#40;ffirst
                      &amp;#40;d/q '&amp;#91;:find ?e
                             :in $ ?u ?t ?s
                             :where
                             &amp;#91;?e :rev-stream/stream-unique-id ?u&amp;#93;
                             &amp;#91;?e :rev-stream/writing-time ?t&amp;#93;
                             &amp;#91;?e :rev-stream/source ?s&amp;#93;&amp;#93;
                           db &amp;#40;:rev-stream/stream-unique-id m&amp;#41;
                           &amp;#40;:rev-stream/writing-time m&amp;#41;
                           &amp;#40;:rev-stream/source m&amp;#41;&amp;#41;&amp;#41;&amp;#93;
           &amp;#91;&amp;#40;-&amp;gt; &amp;#40;dissoc m :rev-stream/stream-unique-id
                        :rev-stream/writing-time
                        :rev-stream/source&amp;#41;
                &amp;#40;assoc :db/id id&amp;#41;&amp;#41;&amp;#93;
           &amp;#91;m&amp;#93;&amp;#41;}}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;cardinality&amp;#95;many&quot;&gt;Cardinality many&lt;/h4&gt;&lt;p&gt;Consider tha table with a cardinality-many schema &lt;code&gt;:order/accounting-data&lt;/code&gt; and &lt;code&gt;:order/product-unique-id&lt;/code&gt; with &lt;code&gt;:db.unique/identity&lt;/code&gt;. How to do upsert when we have &lt;code&gt;txes&lt;/code&gt; like below?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;#:order{:io-writing-time #inst &amp;quot;2019-04-01T02:39:00.000-00:00&amp;quot;,
         :service-category-enum :product.type/today,
         :accounting-data
         &amp;#91;#:accounting{:month &amp;quot;2019-04&amp;quot;, :revenue -2}
          #:accounting{:month &amp;quot;2019-05&amp;quot;, :revenue -3}
          #:accounting{:month &amp;quot;2019-02&amp;quot;, :revenue 4}
          #:accounting{:month &amp;quot;2019-01&amp;quot;, :revenue 5}&amp;#93;}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With a db transaction function &lt;code&gt;upsert-order&lt;/code&gt;, we can simply write &lt;code&gt;txes&lt;/code&gt; as&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  &amp;#91;&amp;#91;:fn/upsert-order
    #:order{:io-writing-time #inst &amp;quot;2019-04-01T02:39:00.000-00:00&amp;quot;,
            :service-category-enum :product.type/today,
            :accounting-data
            &amp;#91;#:accounting{:month &amp;quot;2019-04&amp;quot;, :revenue -2}
             #:accounting{:month &amp;quot;2019-05&amp;quot;, :revenue -3}
             #:accounting{:month &amp;quot;2019-02&amp;quot;, :revenue 4}
             #:accounting{:month &amp;quot;2019-01&amp;quot;, :revenue 5}&amp;#93;}&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The transaction function &lt;code&gt;:fn/upsert-order&lt;/code&gt; handles the upsert complexity.&lt;/p&gt;&lt;pre&gt;&lt;code&gt; {:db/id #db/id &amp;#91;:db.part/user&amp;#93;
  :db/ident :fn/upsert-order
  :db/doc &amp;quot;The :order/accounting-data is cardinality many.
  When insert semantic, transact `&amp;#91;m&amp;#93;`
  When update semantic, do retraction of :order/accounting-data first and then transact `m`  &amp;quot;
  :db/fn #db/fn
  {:lang :clojure
   :params &amp;#91;db m&amp;#93;
   :code &amp;#40;if-let &amp;#91;eid &amp;#40;ffirst
                      &amp;#40;d/q '&amp;#91;:find ?e
                             :in $ ?u
                             :where
                             &amp;#91;?e :order/product-unique-id ?u&amp;#93;&amp;#93;
                           db &amp;#40;:order/product-unique-id m&amp;#41;&amp;#41;&amp;#41;&amp;#93;
           &amp;#40;let &amp;#91;ad-refs &amp;#40;d/q '&amp;#91;:find &amp;#91;?a ...&amp;#93;
                                :in $ ?e
                                :where &amp;#91;?e :order/accounting-data ?a&amp;#93;&amp;#93;
                              db eid&amp;#41;
                 retracts &amp;#40;mapcat &amp;#40;fn &amp;#91;r&amp;#93;  &amp;#91;&amp;#91;:db/retractEntity r&amp;#93;
                                            &amp;#91;:db/retract eid :order/accounting-data r&amp;#93;&amp;#93;&amp;#41; ad-refs&amp;#41;&amp;#93;
             &amp;#40;conj &amp;#40;vec retracts&amp;#41; m&amp;#41;&amp;#41;
           &amp;#91;m&amp;#93;&amp;#41;}}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;&lt;p&gt;From abstracting out idioms and patterns of ETL, I understand that context dependency is the primary cause of the complex application code. Both Datomic transaction functions and regular expression syntaxes of &lt;code&gt;clojure.spec&lt;/code&gt; can help to remove the context dependency of our application code. Use them wisely!&lt;/p&gt;
</description>
<pubDate>
Mon, 01 Jul 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/first-consulting
</guid>
<link>
https://humorless.github.io/posts-output/first-consulting
</link>
<title>
Lessons learned from the software consulting job
</title>
<description>
&lt;p&gt;I live in Taiwan and I can not find Clojure jobs here. Although the first legal gay wedding in Asia took place here, it seems that the real programming language innovation still needs some evangelists to spread it. Therefore, I decide to create Clojure job by myself. In January this year, I had a chance to develop enterprise software for the LINE Taiwan, and I chose Clojure as my primary technical stack.&lt;/p&gt;&lt;h2 id=&quot;technical&amp;#95;stack&amp;#95;issues&quot;&gt;Technical stack issues&lt;/h2&gt;&lt;p&gt;When I discussed with my clients about this enterprise software solution, we focused on the problem domain. However, when I told my clients that I want to use Clojure, Datomic, and ClojureScript, my clients said no. They said a lot of cliches like they never hear Clojure before, it would be difficult to find Clojure programmers. Then, I made some compromises: I would use React with javascript in frontend but Clojure in backend with Datomic as database. For Clojure, I provided the reason that the business requirements had temporal queries which were like a piece of cake for Datomic but very time-consuming for traditional relational databases.&lt;/p&gt;&lt;p&gt;After developing this project for a while, I regretted that I did not insist on ClojureScript. I really spent a lot of time on javascript boilerplate code, and the time spent did not bring any value to my clients.&lt;/p&gt;&lt;h2 id=&quot;a&amp;#95;very&amp;#95;simple&amp;#95;user&amp;#95;login&amp;#95;is&amp;#95;good&amp;#95;enough&amp;#95;for&amp;#95;a&amp;#95;small&amp;#95;group&amp;#95;of&amp;#95;users&quot;&gt;A very simple user login is good enough for a small group of users&lt;/h2&gt;&lt;p&gt;The enterprise software solution needed to be an on-premise solution, installed on the private network at LINE offices. There would be about 30 users login everyday. At the beginning, I thought three different ways to solve the user login problems:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Single signed-on with other enterprise software in LINE&lt;/li&gt;&lt;li&gt;Leverage third party authorization service&lt;/li&gt;&lt;li&gt;Traditional user login backend APIs and frontend UI with login/register/user management functions like resetting password.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Option 2 might be fast enough, but my clients did not like third party service.&lt;/p&gt;&lt;p&gt;My final proposal was a login module like this:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Frontend UI provided the login and password modification functions to ordinary users.&lt;/li&gt;&lt;li&gt;The administrator of this system used ETL (extract-transform-load) to manage user accounts. Given this design, we did not need any user registration or user accounts management UI.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;revenue&amp;#95;spreading&amp;#95;problem&quot;&gt;Revenue spreading problem&lt;/h2&gt;&lt;p&gt;There was a business requirement, I called it as revenue spreading problem, in this enterprise software.&lt;/p&gt;&lt;p&gt;Revenue spreading problem:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;For every order, there is a start date and end date of this order. The total days of an order are &lt;code&gt;&amp;#40;end date - start date + 1&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;For every order, there is a net revenue of this order.&lt;/li&gt;&lt;li&gt;For every order, we need to calculate the monthly revenue. The definition of monthly revenue is &lt;code&gt;net revenue &amp;#42; the revenue days of certain month / total days&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If an order starts at 5/5, ends at 6/8 with total revenue as 35 dollars, then the total days of this order is (27+8) = 35 days. Also, the monthly revenue of May is 27 dollars and monthly revenue of June is 8 dollars.&lt;/p&gt;&lt;p&gt;To solve this, at the beginning, I used &lt;code&gt;first-day-of-the-month&lt;/code&gt; and &lt;code&gt;last-day-of-the-month&lt;/code&gt; in &lt;code&gt;clj-time&lt;/code&gt; library to calculate how many days within a month. The first version solution was a traditional imperative solution. I quickly found that I could do better with functional thinking.&lt;/p&gt;&lt;p&gt;My improved version:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Generate a sequence of time using &lt;code&gt;period-sec&lt;/code&gt; in &lt;code&gt;clj-time&lt;/code&gt;. The period of time is just one day long and the start date/end date are the start date/end date of certain order.&lt;/li&gt;&lt;li&gt;Apply &lt;code&gt;group-by&lt;/code&gt; to the step 1 day sequence with the grouping function that can return the year-month-string of a certain date. For example, a date of 2009/05/01 returns &quot;2019-05&quot;.&lt;/li&gt;&lt;li&gt;Calculate how many days of each group of the step 2 result.&lt;/li&gt;&lt;li&gt;Spread the revenue using step 3 result.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;ci/cd&amp;#95;issues&quot;&gt;CI/CD issues&lt;/h2&gt;&lt;p&gt;I was not an expert of DevOps. When I needed to deploy the project, I took some time to study ansible because the great book &lt;code&gt;Deploying Your First Clojure App ...From the Shadows shows&lt;/code&gt; introduced ansible. I still felt ansible is a great tool worth learning, however, the target servers were under the bastion host.&lt;/p&gt;&lt;p&gt;Engineers in LINE Taiwan told me that they installed a Drone CI/CD server in the virtual private network behind the bastion host. As a Clojure developer, I decided to use LambdaCD. Actually, it was even simpler than Drone. Parentheses abundant lisp clj files were more expressive than yaml files.&lt;/p&gt;&lt;p&gt;When I encountered problems, I asked questions at LambdaCD github repo. Within two days, the author of LambdaCD kindly replied my questions. I thought LambdaCD is worth of recommendation, both the quality of the software and quick response.&lt;/p&gt;&lt;h2 id=&quot;evangelism&amp;#95;of&amp;#95;clojure&quot;&gt;Evangelism of Clojure&lt;/h2&gt;&lt;p&gt;Given that I did software consulting at a big company, I could apply for technical talk inside the company. Grabbing the chance, I introduced Clojure to 10~ developers. Those who already had experience with Scala showed more interests than others. Good beginning anyways, I thought. Here is the &lt;a href='https://www.slideshare.net/humorless/the-productivity-brought-by-clojure-149170292/'&gt;slide&lt;/a&gt; of technical talk.&lt;/p&gt;
</description>
<pubDate>
Sun, 23 Jun 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/assembly
</guid>
<link>
https://humorless.github.io/posts-output/assembly
</link>
<title>
Using datomic with Luminus: Where to put our queries?
</title>
<description>
&lt;p&gt;If we build a Luminus project with db option other than datomic, for example &lt;code&gt;+postgres&lt;/code&gt;, the code arrangement is much more straight forward. Open the file &lt;code&gt;resources/sql/queries.sql&lt;/code&gt;, and put sql query and sql transaction command in this file. Then, we can just &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;xxx.db.core&lt;/code&gt; namespace, the db queries or commands are totally available. &lt;/p&gt;&lt;h2 id=&quot;where&amp;#95;to&amp;#95;put&amp;#95;the&amp;#95;db&amp;#95;queries&amp;#95;if&amp;#95;we&amp;#95;use&amp;#95;db&amp;#95;option&amp;#95;as&amp;#95;+datomic?&quot;&gt;Where to put the db queries if we use db option as +datomic?&lt;/h2&gt;&lt;p&gt;Put datomic queries in the same file with connection state in &lt;code&gt;xxx.db.core&lt;/code&gt; is the first attempt I tried. However, the datomic queries actually execute in the application program runtime, not in the db server runtime. Also, if we design the query function to accept datomic db value as input argument, then our query function will become pure functions.&lt;/p&gt;&lt;p&gt;After discovering that our query functions are pure functions, I decide to arrange my application namespaces like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;prj.&amp;#91;service&amp;#93;.assembly ---&amp;gt; prj.db.core
                            ;; assembly only refers conn variable from prj.db.core
                       ---&amp;gt; datomic.api
                       ---&amp;gt; prj.db.query
                             ;; I make all the query functions as pure functions and put them here.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The namespace &lt;code&gt;&amp;#91;service&amp;#93;.assembly&lt;/code&gt; is used to &lt;em&gt;wire&lt;/em&gt; utility funcitons (pure functions) and stateful things like datomic connection together.&lt;/p&gt;&lt;h2 id=&quot;where&amp;#95;to&amp;#95;put&amp;#95;the&amp;#95;db&amp;#95;transactions?&quot;&gt;Where to put the db transactions?&lt;/h2&gt;&lt;p&gt;Given that &lt;code&gt;&amp;#91;service&amp;#93;.assembly&lt;/code&gt; refers &lt;code&gt;conn&lt;/code&gt;, I decide to call &lt;code&gt;&amp;#40;d/transact conn ... &amp;#41;&lt;/code&gt; in this namespace. However, I still need to do some transformation to get proper transaction data that can directly put into &lt;code&gt;d/transact&lt;/code&gt;. Therefore, the arrangement will be like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;prj.&amp;#91;service&amp;#93;.assembly ---&amp;gt; prj.db.command
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In &lt;code&gt;prj.db.command&lt;/code&gt;, I put the transformation functions that used to create datomic transaction data. The transformation functions are also pure functions.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Compared to traditional sql db option, the reasonable place to put database queries of datomic db option is totally different. &lt;/p&gt;&lt;p&gt;In traditonal sql db options:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We write HugSQL sql sourcre files with sql and tags.&lt;/li&gt;&lt;li&gt;We need integration test to test these queries.&lt;/li&gt;&lt;li&gt;We place our queries in &lt;code&gt;resource/sql/queries.sql&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In datomic db options:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We write Clojure source files with data.&lt;/li&gt;&lt;li&gt;We only need unit test to test these queries.&lt;/li&gt;&lt;li&gt;We place our queries in &lt;code&gt;prj.db.query&lt;/code&gt; namespace.&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Wed, 12 Jun 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/vagrant
</guid>
<link>
https://humorless.github.io/posts-output/vagrant
</link>
<title>
Clojure development environment by Vagrant
</title>
<description>
&lt;p&gt;If you want to have a portable Clojure development environment and you use Vagrant, vim-fireplace, you may consider to try my &lt;a href='https://github.com/humorless/dotfiles'&gt;Vagrantfile&lt;/a&gt;. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;git clone https://github.com/humorless/dotfiles
cd dotfiles
vagrant up
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;certain&amp;#95;part&amp;#95;of&amp;#95;vagrantfile&amp;#95;you&amp;#95;may&amp;#95;need&amp;#95;to&amp;#95;remove.&quot;&gt;Certain part of vagrantfile you may need to remove.&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;if Vagrant.has&amp;#95;plugin?&amp;#40;&amp;quot;vagrant-timezone&amp;quot;&amp;#41;
  config.timezone.value = &amp;quot;Asia/Taipei&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;the&amp;#95;beginning&amp;#95;of&amp;#95;this&amp;#95;repo&quot;&gt;The beginning of this repo&lt;/h2&gt;&lt;p&gt;Several years before, I created a github repo called &lt;code&gt;dotfiles&lt;/code&gt;, which is used to record my vimrc file. Later, every time when I changed my job, I modified my favorite vim plugin. I modified my vim plugin collection so many times. Sometimes, I installed certain vim cool plugin, but after a while, I totally forgot how to use it. There are not too many vim plugins in this dotfiles, because I am not a vim &lt;code&gt;l33t hax0r&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;development&amp;#95;and&amp;#95;deployment&quot;&gt;development and deployment&lt;/h2&gt;&lt;p&gt;I have had a job that I needed to work at AWS cloud9 environment. Some of my jobs required me to install totally new development environment. Recently, I needed to deploy Clojure enviroment on production system, so I learned a little &lt;code&gt;ansible&lt;/code&gt; and I used ansible to install java8.&lt;/p&gt;&lt;p&gt;One day, I found that vagrant can use ansible to do provisioning, so I combined them together.&lt;/p&gt;&lt;h2 id=&quot;some&amp;#95;nice&amp;#95;tools&amp;#95;i&amp;#95;cannot&amp;#95;live&amp;#95;without&quot;&gt;Some nice tools I cannot live without&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nvm&lt;/code&gt; is important to me because I usually need to change node version. &lt;code&gt;autojump&lt;/code&gt; is also important. &lt;/p&gt;
</description>
<pubDate>
Mon, 13 May 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/datomic
</guid>
<link>
https://humorless.github.io/posts-output/datomic
</link>
<title>
Using Datomic in my app
</title>
<description>
&lt;h2 id=&quot;the&amp;#95;background&amp;#95;of&amp;#95;this&amp;#95;post&quot;&gt;The background of this post&lt;/h2&gt;&lt;p&gt;I began to use Datomic seriously in my project at work from February 2019. Now, it is time to write down certain experience. When I just began, I found a lot of documents talking about how to use Datomic. However, I still found certain points worth to mention from my project.&lt;/p&gt;&lt;h2 id=&quot;query&amp;#95;api&amp;#95;and&amp;#95;pull&amp;#95;api&amp;#95;are&amp;#95;enough&quot;&gt;Query API and Pull API are enough&lt;/h2&gt;&lt;p&gt;When I just begin to write Datomic, soon I found &lt;a href='https://vvvvalvalval.github.io/posts/2016-07-24-datomic-web-app-a-practical-guide.html'&gt;post&lt;/a&gt; from Val. In the post, Val used Entity API. &lt;/p&gt;&lt;p&gt;In my project, I used only Query API and Pull API. Query API was for taking out entity id mostly and Pull API was for pulling out necessary field or sometimes doing some 'join'. I think the article &lt;a href='http://blog.cognitect.com/blog/2017/4/21/separation-of-concerns-in-datomic-query-datalog-query-and-pull-expressions'&gt;SEPARATION OF CONCERNS IN DATOMIC QUERY: DATALOG QUERY AND PULL EXPRESSIONS&lt;/a&gt; has explained similar idea. Entity API is also good, but Pull API is even better.&lt;/p&gt;&lt;h2 id=&quot;occasionally,&amp;#95;a&amp;#95;generalized&amp;#95;cas&amp;#95;(compare-and-swap)&amp;#95;is&amp;#95;needed,&amp;#95;or&amp;#95;you&amp;#95;need&amp;#95;to&amp;#95;use&amp;#95;stamp.&quot;&gt;Occasionally, a generalized CAS (compare-and-swap) is needed, or you need to use stamp.&lt;/h2&gt;&lt;p&gt;In my project, I need to use Datomic to model:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The user can propose request. Initially, the request is in open status.&lt;/li&gt;&lt;li&gt;The admin can approve/reject/modify the user request.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The request schema is like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:req/status     ;; cardinality one. It can be - open, modified, approved, rejected
:req/things     ;; cardinality many. &amp;#91;thing-id ...&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The admin sees the user requests from a web application UI. There are three options for admin: approve, reject, modify. If a request is approved or rejected, then this request is no longer alive. It will disappear from admin UI. However, if a request is modified, it can still be approved, be rejected, or be modified again. When the request is modified, only the &lt;code&gt;req/things&lt;/code&gt; can be modified. There may be multiple admins operating at the same time on the same request in this system.&lt;/p&gt;&lt;p&gt;The state diagram of request status is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; open -&amp;gt; modified 
 modified -&amp;gt; modified 
 {modified, open} -&amp;gt; approved &amp;#40;done&amp;#41;
 {modified, open} -&amp;gt; rejected &amp;#40;done&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Consider a situation: Two admins A and B process on the same request and they do not sense each other. They push the button at the same time. One admin A approves the request and another admin B modifies the request. The request was originally modified before, so it is at the status &lt;code&gt;modified&lt;/code&gt; when the two admins process it.&lt;/p&gt;&lt;p&gt;The correct behavior of the system could be two possibilities: Either operation of admin A is successful or operation of admin B is successful. If operation of admin A is successful first, then the request can not be modified anymore. If the operation of admin B is successful first, then the approval of A should not happen, because the &lt;code&gt;req/things&lt;/code&gt; is already modified, but the admin A approved different set of &lt;code&gt;req/things&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I consider to utilize &lt;code&gt;db.fn/cas&lt;/code&gt; to guarantee that only one operation of admin A or admin B can succeed. However, &lt;code&gt;db.fn/cas&lt;/code&gt; does not work on attributes with cardinality many.&lt;/p&gt;&lt;p&gt;I think there are two ways to solve this mutually exclusive concurrent operation problem:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Add an extra schema &lt;code&gt;req/stamp&lt;/code&gt; into req. The stamp is initially 0. Every operation will increase it by 1. Then I can use this stamp and &lt;code&gt;db.fn/cas&lt;/code&gt; to ensure the logically strictness of the operations.&lt;/li&gt;&lt;li&gt;Install some customized db function, which can do CAS on cardinality many to ensure the logically strictness.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;db&amp;#95;enumeration&quot;&gt;DB Enumeration&lt;/h2&gt;&lt;p&gt;I use &lt;code&gt;:db/ident&lt;/code&gt; to do enumerations in my project:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;:db/add #db/id &amp;#91;:db.part/user&amp;#93; :db/ident :product.type/account&amp;#93;
&amp;#91;:db/add #db/id &amp;#91;:db.part/user&amp;#93; :db/ident :product.type/display&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;They are enumerations that represent the different products. Then, there are certain related issues associated with this modeling.&lt;/p&gt;&lt;h3 id=&quot;how&amp;#95;to&amp;#95;pull&amp;#95;out&amp;#95;all&amp;#95;the&amp;#95;enumerations&amp;#95;of&amp;#95;the&amp;#95;same&amp;#95;type?&quot;&gt;How to pull out all the enumerations of the same type?&lt;/h3&gt;&lt;p&gt;I deliberately set the enumeration of the same type with the same namespace, so I need to prepare a query that can filter based on the same namespace. It is very convenient that we can directly use Clojure function in Datomic query.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn product-enum-eids
  &amp;quot;all the product enumeration eids&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;d/q '&amp;#91;:find &amp;#91;?e ...&amp;#93;
         :in $ ?nsp
         :where &amp;#91;?e :db/ident ?attr&amp;#93;
         &amp;#91;&amp;#40;namespace ?attr&amp;#41; ?nsp&amp;#93;&amp;#93;     ;;Datomic Function expression binds the ?nsp variable
       db &amp;quot;product.type&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;how&amp;#95;to&amp;#95;store&amp;#95;the&amp;#95;external&amp;#95;string&amp;#95;and&amp;#95;enumeration&amp;#95;mapping&amp;#95;in&amp;#95;datomic?&quot;&gt;How to store the external string and enumeration mapping in Datomic?&lt;/h3&gt;&lt;p&gt;Once again, I use simple schema with no magic.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   {:db/doc &amp;quot;External name associated with a db enumeration value&amp;quot;
    :db/ident :enum/name
    :db/valueType :db.type/string
    :db/cardinality :db.cardinality/one
    :db/unique :db.unique/identity
    :db/id #db/id &amp;#91;:db.part/db&amp;#93;
    :db.install/&amp;#95;attribute :db.part/db}

   {:db/doc &amp;quot;db enumeration value&amp;quot;
    :db/ident :enum/value
    :db/valueType :db.type/ref
    :db/cardinality :db.cardinality/one
    :db/unique :db.unique/identity
    :db/id #db/id &amp;#91;:db.part/db&amp;#93;
    :db.install/&amp;#95;attribute :db.part/db}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we need to import data from files and we need to map external names to DB enumeration values, we can pull out all the mapping at once. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn name2enum-table
  &amp;quot;create a mapping table that can lookup enumeration from string name.&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;into {}  &amp;#40;d/q '&amp;#91;:find ?k ?enum
                   :where
                   &amp;#91;?e :enum/name ?k&amp;#93;
                   &amp;#91;?e :enum/value ?v&amp;#93;
                   &amp;#91;?v :db/ident ?enum&amp;#93;&amp;#93;
                 db&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Sat, 27 Apr 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/REPL
</guid>
<link>
https://humorless.github.io/posts-output/REPL
</link>
<title>
REPL tips
</title>
<description>
&lt;p&gt;從今年 2 月開始，接了一個公司內部應用軟體的專案開發，我用 clojure + luminus + datomic 來實作。不知不覺也就每天寫 clojure 的 REPL 近兩個月了。每天玩 REPL 之後，很快就發現一些過去我用 REPL 的盲點。&lt;/p&gt;&lt;h3 id=&quot;沒有善用&amp;#95;&lt;code&gt;clojure.repl/pprint&lt;/code&gt;&quot;&gt;沒有善用 &lt;code&gt;clojure.repl/pprint&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;  沒有善用的主要原因，自然是因為在 &lt;code&gt;fireplace.vim&lt;/code&gt; 的環境下，一開始我沒有特別做一些設定時，直接做 cpp, cqp 之類 REPL 操作，並不會有 pretty print 的輸出。後來，我總算是下定決心，把 &lt;a href='https://github.com/humorless/dotfiles/blob/master/profiles.clj'&gt;leiningen profiles&lt;/a&gt; 設定好，加入了一個叫 &lt;code&gt;vinyasa&lt;/code&gt; 的 leiningen dependency&lt;/p&gt;&lt;p&gt;  設定好之後，就可以用 &lt;code&gt;&amp;#40;&amp;gt;pprint ...&amp;#41;&lt;/code&gt; 來做 pretty print 。&lt;/p&gt;&lt;h3 id=&quot;沒有善用&amp;#95;&lt;code&gt;&amp;#42;1&lt;/code&gt;&amp;#95;&lt;code&gt;&amp;#42;2&lt;/code&gt;&quot;&gt;沒有善用 &lt;code&gt;&amp;#42;1&lt;/code&gt; &lt;code&gt;&amp;#42;2&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;  過去，我在做 REPL 操作時，常常做的事情是這樣子：&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f1 a b c&amp;#41;&lt;/code&gt; =&gt; 試到結果正確&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f2 &amp;#40;f1 a b c&amp;#41; d&amp;#41;&lt;/code&gt; =&gt; 也是試到結果也正確&lt;/p&gt;&lt;p&gt;  &lt;code&gt;&amp;#40;f3 &amp;#40;f2 &amp;#40;f1 a b c&amp;#41; d&amp;#41; e&amp;#41;&lt;/code&gt; =&gt; 然後指令就愈來愈長, 愈來愈難下&lt;/p&gt;&lt;p&gt;  其實不用這樣子麻煩，第二次可以這樣子下指令 &lt;code&gt;&amp;#40;f2 &amp;#42;1 d&amp;#41;&lt;/code&gt; 。&lt;/p&gt;
</description>
<pubDate>
Sat, 30 Mar 2019 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/dependency-injection
</guid>
<link>
https://humorless.github.io/posts-output/dependency-injection
</link>
<title>
dependency injection with Clojure
</title>
<description>
&lt;p&gt;寫 clojure 的時候，雖然套用了 REPL-driven development 的開發方式，已經相對可以讓大多數的函數很快地做過測試。但是，隨著要開發的專案愈來愈大，還是一樣需要用標準的寫法來寫單元測試 (unit test) 。有一個非正規的統計，如果是 Ruby on Rail 的專案，一般而言，90% 的函數都是有副作用的。然而， clojure 語言的專案，往往只有 40% 的函數帶有副作用。&lt;/p&gt;&lt;p&gt;即使是寫 clojure 語言，還是會遇到有 side effect 的函數，那比較好的寫法是怎麼樣呢？&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;p&gt;我查了一下 stackoverflow 之後，很快就找到了一個很好用的函數 &lt;code&gt;with-redefs&lt;/code&gt; 。 stackoverflow 上的答案大意如下： 由於 clojure 語言有 Dynamic binding 的特性，使用 &lt;code&gt;with-redefs&lt;/code&gt; 就可以實現同樣的語意了。&lt;/p&gt;&lt;p&gt;我試了一下，還真的管用，範例如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;deftest platform-contact-test
  &amp;#40;testing &amp;quot;platform-contact&amp;quot;
    ; use the DI technique to test the function platform-contact
    &amp;#40;is &amp;#40;= 170
           &amp;#40;with-redefs &amp;#91;get-platform-contact &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;slurp &amp;quot;./resources/contact&amp;#95;data.txt&amp;quot;&amp;#41;&amp;#41;&amp;#93;
             &amp;#40;count &amp;#40;platform-contact &amp;#40;temp-platform-all&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在這個範例中，原本的 &lt;code&gt;get-platform-contact&lt;/code&gt; 函數是一個有副作用的函數，它會被 &lt;code&gt;platform-contact&lt;/code&gt; 函數呼叫。 &lt;code&gt;get-platform-contact&lt;/code&gt; 函數會發出一個 http request ，並且傳回遠端 server 上的資料，所以如果沒有加以代換，單元測試就會非常慢。用了 &lt;code&gt;with-redefs&lt;/code&gt; 之後，就可以輕易地將 &lt;code&gt;get-platform-contact&lt;/code&gt; 代換成一個會傳回固定檔案資料的函數，如此就可以執行快速的單元測試了。&lt;/p&gt;&lt;p&gt;對於 clojure 這種先進的特性， stackoverflow 上有一句評論： Needing a framework for DI is really just compensating for a lack of sufficient features in the language itself.&lt;/p&gt;
</description>
<pubDate>
Wed, 12 Jul 2017 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/groupby
</guid>
<link>
https://humorless.github.io/posts-output/groupby
</link>
<title>
groupby
</title>
<description>
&lt;p&gt;一開始是我在寫 &lt;a href='http://www.4clojure.com/problem/63'&gt;4clojure&lt;/a&gt; 的練習題的時候，寫到了一個題目，要重新實現 clojure 語言的 groupby 函數。我糾結了好一陣子，又查了不少資料，才勉強用 reduce 寫出來。然而，最近卻在工作中，用上了 groupby 。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn f &amp;#91;k coll&amp;#93;
  &amp;#40;reduce
    &amp;#40;fn &amp;#91;c v&amp;#93;
      &amp;#40;update-in c &amp;#91;&amp;#40;k v&amp;#41;&amp;#93; &amp;#40;fnil conj &amp;#91;&amp;#93;&amp;#41; v&amp;#41;&amp;#41;
    {} coll&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt; 工作上遇到的問題是要重構同事寫的程式碼。程式碼做的事情是：「接受資料庫 dump 的 json 輸出，跑兩層很複雜的迴圈，對原始的資料做主鍵交換的處理，然後將資料存入 mysql 資料庫。」資料庫 dump 出來的 json 大概長成如下的樣子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;  &amp;quot;result&amp;quot;: &amp;#91;
    {
      &amp;quot;platform&amp;quot;: &amp;quot;c01.i01&amp;quot;,
      &amp;quot;ip&amp;#95;list&amp;quot;: &amp;#91;
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.168.0.1&amp;quot;,
          &amp;quot;hostname&amp;quot;: &amp;quot;ggyy6699&amp;quot;
        },
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.169.1.1&amp;quot;,
          &amp;quot;hostname:&amp;quot;: &amp;quot;ggyy7700&amp;quot;
        }
      &amp;#93;
    },
    {
      &amp;quot;platform&amp;quot;: &amp;quot;c01.i05&amp;quot;,
      &amp;quot;ip&amp;#95;list&amp;quot;: &amp;#91;
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.168.0.2&amp;quot;,
          &amp;quot;hostname&amp;quot;: &amp;quot;ggkk8899&amp;quot;
        },
        {
          &amp;quot;ip&amp;quot;: &amp;quot;192.169.1.2&amp;quot;,
          &amp;quot;hostname:&amp;quot;: &amp;quot;ggkk9900&amp;quot;
        }
      &amp;#93;
    }
  &amp;#93;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;從這個 json 來看的話，&lt;code&gt;platform&lt;/code&gt; 是主鍵 (primary key) 。而每一個 &lt;code&gt;platform&lt;/code&gt; 下之下會有多個 &lt;code&gt;hostname&lt;/code&gt; 。而程式碼做的事情是，先解析這個 json ，重新整理之後，讓 &lt;code&gt;hostname&lt;/code&gt; 變成主鍵 (primary key) ，並且做成一行又一行的 row ，最後要存入關聯式資料庫。讓我感到困擾的地方是因為整理屬性與屬性之間複雜關系的程式碼，都塞在雙重迴圈裡頭，所以雙重迴圈就變得很複雜，而且這一段雙重迴圈的程式碼也無法複用，難以修改、難以維護。&lt;/p&gt;&lt;p&gt;轉換成用資料庫的觀點來看待這個問題之後，就得到了還不錯的解法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;資料庫的 dump 輸出，本質上也是 join 兩張資料表的結果輸出，所以主鍵 (primary key) 本來就有可能交換。&lt;/li&gt;&lt;li&gt;既然要解析的資料是 join 之後的結果，所以有效的處理方式是這樣子：&lt;ol&gt;&lt;li&gt;先將 json 的資料跑完簡單的雙重迴圈，雙重迴圈只做一件事，只將將資料做展開 (unfolding)，變成 join 完成的樣子。&lt;/li&gt;&lt;li&gt;python 的 &lt;code&gt;itertools.groupby&lt;/code&gt; ，可以讓資料表 (table) 重新整理，產生出以任意的 column 做為主鍵 (primary key) 的新資料表 (table)。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程式碼如下：&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def get&amp;#95;h&amp;#95;platforms&amp;#40;res&amp;#41;:
    &amp;quot;&amp;quot;&amp;quot; sample output
    ctl-zj-061-130-028-019 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    ctl-zj-061-130-028-020 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    ctl-zj-061-130-028-022 &amp;#91;'c01.p02', 'c01.p02-kugou'&amp;#93;
    &amp;quot;&amp;quot;&amp;quot;
    product = &amp;#91;&amp;#40;p&amp;#91;&amp;quot;platform&amp;quot;&amp;#93;, device&amp;#91;&amp;quot;hostname&amp;quot;&amp;#93;&amp;#41;
               for p in res&amp;#91;&amp;quot;result&amp;quot;&amp;#93; for device in p&amp;#91;&amp;quot;ip&amp;#95;list&amp;quot;&amp;#93;&amp;#93;
    data = sorted&amp;#40;product, key=lambda x: x&amp;#91;1&amp;#93;&amp;#41;
    for key, grp in itertools.groupby&amp;#40;data, key=lambda x: x&amp;#91;1&amp;#93;&amp;#41;:
        print&amp;#40;key, list&amp;#40;map&amp;#40;lambda x: x&amp;#91;0&amp;#93;, set&amp;#40;grp&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sun, 21 May 2017 00:00:00 +0000
</pubDate>
</item>
<item>
<guid>
https://humorless.github.io/posts-output/pattern
</guid>
<link>
https://humorless.github.io/posts-output/pattern
</link>
<title>
pattern
</title>
<description>
&lt;h2 id=&quot;patterns&amp;#95;=&amp;#95;programming&amp;#95;with&amp;#95;abstactions&amp;#95;that&amp;#95;are&amp;#95;not&amp;#95;powerful&amp;#95;enough&quot;&gt;patterns = programming with abstactions that are not powerful enough&lt;/h2&gt;&lt;p&gt;先來引述一下 Paul Graham 的句子&lt;blockquote&gt;&lt;p&gt; When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I'm using abstractions that aren't powerful enough. &lt;/p&gt;&lt;footer&gt; Paul Graham - Revenge of the Nerds&lt;/footer&gt; &lt;/blockquote&gt;為了想出可以妥善解釋這段話的意思的 non-trivial 範例，其實我還想了滿久的。不料真的就在我學習 clojure 語言的過程之中找到了。這個範例是對某個 array 的每一個元素，做相同的運算處理：一個是循序處理、一個是平行處理。&lt;/p&gt;&lt;p&gt;&lt;!&amp;ndash;more&amp;ndash;&gt;&lt;/p&gt;&lt;h3 id=&quot;golang&amp;#95;的兩個版本&quot;&gt;golang 的兩個版本&lt;/h3&gt;&lt;p&gt;循序處理的版本&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;res := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
for i,xi := range data {
    func &amp;#40;i int, xi float&amp;#41; {
        res&amp;#91;i&amp;#93; = doSomething&amp;#40;i,xi&amp;#41;;
    } &amp;#40;i, xi&amp;#41;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;平行處理的版本&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;type empty {}
...
data := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
res := make&amp;#40;&amp;#91;&amp;#93;float, N&amp;#41;;
sem := make&amp;#40;chan empty, N&amp;#41;;  // semaphore pattern
...
for i,xi := range data {
    go func &amp;#40;i int, xi float&amp;#41; {
        res&amp;#91;i&amp;#93; = doSomething&amp;#40;i,xi&amp;#41;;
        sem &amp;lt;- empty{};
    } &amp;#40;i, xi&amp;#41;;
}
// wait for goroutines to finish
for i := 0; i &amp;lt; N; ++i { &amp;lt;-sem }
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;h3 id=&quot;clojure&amp;#95;的兩個版本&quot;&gt;clojure 的兩個版本&lt;/h3&gt;&lt;p&gt;循序處理的版本&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn myfun &amp;#91;coll&amp;#93;
  &amp;#40;map doSomething coll&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;平行處理的版本&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn myfun &amp;#91;coll&amp;#93;
  &amp;#40;pmap doSomething coll&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;抽象層次的差異&quot;&gt;抽象層次的差異&lt;/h3&gt;&lt;p&gt;比較這兩種語言寫的四段程式碼，很快可以發現，循序處理的範例都相當的簡單。然而，當換成平行處理的版本時， golang 的實作比 clojure 難多了。需要用 golang 的 channel 做出一個 semaphore 的 pattern 才能實現。而相較之下， clojure 把 map 換成 pmap 就可以了。由此可見， clojure 在這個例子之中，是一種足夠強的抽象層，可以輕易地去表達這個平行處理的語意。&lt;/p&gt;
</description>
<pubDate>
Tue, 28 Feb 2017 00:00:00 +0000
</pubDate>
</item>
</channel>
</rss>
